package main

import (
	"fmt"
	"time"
)

// Функция or объединяет несколько каналов и возвращает новый канал,
// который закрывается, если любой из входных каналов закроется.
func or(channels ...<-chan interface{}) <-chan interface{} {
	// Создаем новый канал, который будет объединенным каналом.
	merged := make(chan interface{})
	// Создаем канал для сигнализации завершения работы одного из входных каналов.
	done := make(chan struct{})

	// Запускаем горутину, которая будет заниматься объединением каналов.
	go func() {
		// Закрываем объединённый канал после завершения работы горутины.
		defer close(merged)

		// Проходим по всем входным каналам.
		for _, ch := range channels {
			// Запускаем горутину для каждого входного канала.
			go func(ch <-chan interface{}) {
				// Ожидаем, пока входной канал закроется.
				<-ch

				// Используем select для проверки, был ли уже закрыт канал `done`.
				select {
				case <-done:
					// Если канал `done` уже закрыт, ничего не делаем.
				default:
					// Если канал `done` еще открыт, закрываем его.
					close(done)
				}
			}(ch)
		}

		// Ждем сигнал о завершении из канала `done`.
		<-done
		// Закрываем объединённый канал после получения сигнала о завершении.
	}()

	// Возвращаем объединённый канал.
	return merged
}

func main() {
	// Функция sig создает канал, который закроется через заданный интервал времени.
	sig := func(after time.Duration) <-chan interface{} {
		// Создаем новый канал.
		c := make(chan interface{})
		// Запускаем горутину, которая закроет канал после заданного времени.
		go func() {
			defer close(c)    // Закрываем канал, когда горутина завершится.
			time.Sleep(after) // Ждем заданное время.
		}()
		// Возвращаем созданный канал.
		return c
	}

	// Записываем текущее время, чтобы измерить, сколько времени прошло.
	start := time.Now()

	// Объединяем несколько каналов с разными интервалами задержки.
	<-or(
		sig(2*time.Hour),   // Канал, который закроется через 2 часа.
		sig(5*time.Minute), // Канал, который закроется через 5 минут.
		sig(1*time.Second), // Канал, который закроется через 1 секунду.
		sig(1*time.Hour),   // Канал, который закроется через 1 час.
		sig(1*time.Minute), // Канал, который закроется через 1 минуту.
	)

	// Выводим время, через которое завершилась программа.
	fmt.Printf("done after %v\n", time.Since(start))
}
